
# name: Deploy to Staging Environment
# on:
#   workflow_call:

# jobs:
#   deploy-staging:
#     runs-on: ubuntu-latest
#     name: Deploy to Staging Environment
#     env:
#       # Next.js Application
#       APP_PORT: 3000

#       # External Redis Sentinel Configuration (Use Digital Ocean Public IP)
#       REDIS_SENTINELS_DEV: 157.230.253.3:26379,157.230.253.3:26380,157.230.253.3:26381
#       REDIS_HOST_DEV: 157.230.253.3
#       REDIS_PORT: 6379

#       # Redis Configuration
#       REDIS_MASTER_NAME: mymaster
#       REDIS_PASSWORD: your_redis_password
#       REDIS_SENTINEL_PASSWORD: your_redis_password
#       REDIS_SENTINEL_QUORUM: 3

#       # Sentinel Ports
#       SENTINEL_1_PORT: 26379
#       SENTINEL_2_PORT: 26380
#       SENTINEL_3_PORT: 26381

#       # Redis Ports
#       REDIS_MASTER_PORT: 6379
#       REDIS_SLAVE_1_PORT: 6380
#       REDIS_SLAVE_2_PORT: 6381

#       MASTER_POLL_INTERVAL_MS: 5000

#       IS_DEV: true

#       # Canary Deployment Settings
#       CANARY_WEIGHT: 20

#       # Staging deployment settings (passed from secrets)
#       STAGING_HOST: ${{ secrets.STAGING_HOST }}
#       STAGING_USER: ${{ secrets.STAGING_USER }}
#       STAGING_SSH_KEY: ${{ secrets.STAGING_SSH_KEY }}

#     steps:
#       - name: Echo Staging Secrets (For Debugging)
#         run: |
#           echo "STAGING_HOST: ${{ secrets.STAGING_HOST }}"
#           echo "STAGING_USER: ${{ secrets.STAGING_USER }}"
#           echo "STAGING_SSH_KEY: ${{ secrets.STAGING_SSH_KEY }}"  # Be cautious about exposing private keys

#       - name: Verify Staging Secrets
#         run: |
#           for secret in STAGING_HOST STAGING_USER STAGING_SSH_KEY; do
#             if [ -z "${!secret}" ]; then
#               echo "::error::Secret $secret is not set"
#               exit 1
#             fi
#           done

#       - name: Checkout Repository
#         uses: actions/checkout@v4

#       - name: Set repository name lower-case
#         id: repo
#         run: |
#           repo=$(echo "${GITHUB_REPOSITORY}" | tr '[:upper:]' '[:lower:]')
#           echo "repo=${repo}" >> $GITHUB_OUTPUT

#       - name: Copy all files to remote server, excluding node_modules
#         uses: appleboy/scp-action@master
#         with:
#           host: ${{ secrets.STAGING_HOST }}
#           username: ${{ secrets.STAGING_USER }}
#           key: ${{ secrets.STAGING_SSH_KEY }}
#           source: './*' 
#           target: '/home/${{ secrets.STAGING_USER }}/app'

#       - name: Deploy to Staging Environment
#         uses: appleboy/ssh-action@master
#         with:
#           host: ${{ secrets.STAGING_HOST }}
#           username: ${{ secrets.STAGING_USER }}
#           key: ${{ secrets.STAGING_SSH_KEY }}
#           script: |
#             set -euo pipefail
#             mkdir -p /home/${{ secrets.STAGING_USER }}/app
#             cd /home/${{ secrets.STAGING_USER }}/app

#             # Check if Docker is installed, and install it if not
#             if ! command -v docker &> /dev/null; then
#               echo "Docker not found, installing..."
#               sudo apt-get update
#               sudo apt-get install -y docker.io
#               sudo systemctl start docker
#               sudo systemctl enable docker
#               sudo usermod -aG docker $USER
#             else
#               echo "Docker is already installed"
#             fi

#             # Check if docker-compose is installed, and install it if not
#             if ! command -v docker-compose &> /dev/null; then
#               echo "docker-compose not found, installing..."
#               sudo apt-get update
#               sudo apt-get install -y docker-compose
#             else
#               echo "docker-compose is already installed"
#             fi

#             echo "Logging into GitHub Container Registry..."
#             echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

#             # Create .env file from example or update if exists
#             if [ ! -f .env ]; then
#               cp .env.example .env
#             fi

#             # Update environment variables
#             cat <<EOF >> .env
#             NODE_ENV=development
#             PORT=${{ env.APP_PORT }}
#             REDIS_SENTINELS_DEV=${{ env.REDIS_SENTINELS_DEV }}
#             REDIS_HOST_DEV=${{ env.REDIS_HOST_DEV }}
#             REDIS_PORT=${{ env.REDIS_PORT }}
#             REDIS_MASTER_NAME=${{ env.REDIS_MASTER_NAME }}
#             REDIS_PASSWORD=${{ env.REDIS_PASSWORD }}
#             REDIS_SENTINEL_PASSWORD=${{ env.REDIS_SENTINEL_PASSWORD }}
#             REDIS_SENTINEL_QUORUM=${{ env.REDIS_SENTINEL_QUORUM }}
#             IS_DEV=${{ env.IS_DEV }}
#             CANARY_WEIGHT=${{ env.CANARY_WEIGHT }}
#             EOF

#             # Create or update docker-compose.override.yml for staging
#             cat <<EOF > docker-compose.override.yml
#             version: '3.8'
#             services:
#               app:
#                 image: ghcr.io/${{ steps.repo.outputs.repo }}:staging-latest
#                 ports:
#                   - "80:${{ env.APP_PORT }}"
#                 environment:
#                   - NODE_ENV=development
#                   - PORT=${{ env.APP_PORT }}
#                   - REDIS_SENTINELS_DEV=${{ env.REDIS_SENTINELS_DEV }}
#                   - REDIS_HOST_DEV=${{ env.REDIS_HOST_DEV }}
#                   - REDIS_PORT=${{ env.REDIS_PORT }}
#                   - REDIS_MASTER_NAME=${{ env.REDIS_MASTER_NAME }}
#                   - REDIS_PASSWORD=${{ env.REDIS_PASSWORD }}
#                   - REDIS_SENTINEL_PASSWORD=${{ env.REDIS_SENTINEL_PASSWORD }}
#                   - REDIS_SENTINEL_QUORUM=${{ env.REDIS_SENTINEL_QUORUM }}
#                   - IS_DEV=${{ env.IS_DEV }}
#                   - CANARY_WEIGHT=${{ env.CANARY_WEIGHT }}
#                 restart: always
#             EOF

#             # Pull the latest image and tag as staging-latest
#             docker pull ghcr.io/${{ steps.repo.outputs.repo }}:staging-latest

#             # Tag the current 'staging-latest' image as 'previous' if it exists
#             CURRENT_IMAGE=$(docker images ghcr.io/${{ steps.repo.outputs.repo }}:staging-latest -q)
#             if [ ! -z "$CURRENT_IMAGE" ]; then
#               echo "Tagging current latest image as previous..."
#               docker tag "$CURRENT_IMAGE" ghcr.io/${{ steps.repo.outputs.repo }}:previous
#             fi

#             # Stop and remove any existing containers from previous deployments
#             echo "Stopping any existing containers..."
#             docker-compose down || true

#             # Start new containers
#             echo "Starting new containers..."
#             docker-compose up -d

#             # Prune unused images to free up space
#             echo "Pruning dangling images..."
#             docker image prune -f

#             # Remove old images except 'staging-latest' and 'previous'
#             echo "Removing old images except 'staging-latest' and 'previous'..."
#             docker images ghcr.io/${{ steps.repo.outputs.repo }} --format "{{.Repository}}:{{.Tag}}" | grep -v ":staging-latest$" | grep -v ":previous$" | xargs -r docker rmi -f || true

#             echo "Deployment to staging completed successfully."

name: Deploy to Staging Environment
on:
  workflow_call:
    # Define required inputs and secrets
    secrets:
      STAGING_HOST:
        required: true
      STAGING_USER:
        required: true
      STAGING_SSH_KEY:
        required: true
      REDIS_PASSWORD:
        required: true
      REDIS_SENTINEL_PASSWORD:
        required: true

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    name: Deploy to Staging Environment
    env:
      # Next.js Application
      APP_PORT: 3000

      # Redis Configuration (moved sensitive values to secrets)
      REDIS_SENTINELS_DEV: 157.230.253.3:26379,157.230.253.3:26380,157.230.253.3:26381
      REDIS_HOST_DEV: 157.230.253.3
      REDIS_PORT: 6379
      REDIS_MASTER_NAME: mymaster
      REDIS_SENTINEL_QUORUM: 3

      # Sentinel Ports
      SENTINEL_1_PORT: 26379
      SENTINEL_2_PORT: 26380
      SENTINEL_3_PORT: 26381

      # Redis Ports
      REDIS_MASTER_PORT: 6379
      REDIS_SLAVE_1_PORT: 6380
      REDIS_SLAVE_2_PORT: 6381

      MASTER_POLL_INTERVAL_MS: 5000

      IS_DEV: true

      # Canary Deployment Settings
      CANARY_WEIGHT: 20

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set repository name lower-case
        id: repo
        run: |
          repo=$(echo "${GITHUB_REPOSITORY}" | tr '[:upper:]' '[:lower:]')
          echo "repo=${repo}" >> $GITHUB_OUTPUT

      - name: Setup SSH key and known hosts
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.STAGING_SSH_KEY }}
          name: id_rsa
          known_hosts: ${{ secrets.STAGING_HOST }}
          if_key_exists: replace

      - name: Copy files to remote server, excluding unnecessary files
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          source: "./*,!.git/**,!node_modules/**,!.github/**,!tests/**,!**/*.log,!.cache/**"
          target: '/home/${{ secrets.STAGING_USER }}/app'
          rm: false
          strip_components: 0
          overwrite: true

      - name: Deploy to Staging Environment
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            set -euo pipefail
            cd /home/${{ secrets.STAGING_USER }}/app

            # Ensure directory exists
            mkdir -p /home/${{ secrets.STAGING_USER }}/app

            # Check if Docker is installed, and install it if not
            if ! command -v docker &> /dev/null; then
              echo "Docker not found, installing..."
              sudo apt-get update
              sudo apt-get install -y apt-transport-https ca-certificates curl gnupg lsb-release
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
              echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
              sudo apt-get update
              sudo apt-get install -y docker-ce docker-ce-cli containerd.io
              sudo systemctl start docker
              sudo systemctl enable docker
              sudo usermod -aG docker ${{ secrets.STAGING_USER }}
            else
              echo "Docker is already installed"
            fi

            # Check if docker-compose is installed, and install it if not
            if ! command -v docker-compose &> /dev/null; then
              echo "docker-compose not found, installing..."
              sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.3/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            else
              echo "docker-compose is already installed"
            fi

            echo "Logging into GitHub Container Registry..."
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Create .env file with secure handling of secrets
            cat > .env <<EOF
            NODE_ENV=development
            PORT=${{ env.APP_PORT }}
            REDIS_SENTINELS_DEV=${{ env.REDIS_SENTINELS_DEV }}
            REDIS_HOST_DEV=${{ env.REDIS_HOST_DEV }}
            REDIS_PORT=${{ env.REDIS_PORT }}
            REDIS_MASTER_NAME=${{ env.REDIS_MASTER_NAME }}
            REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
            REDIS_SENTINEL_PASSWORD=${{ secrets.REDIS_SENTINEL_PASSWORD }}
            REDIS_SENTINEL_QUORUM=${{ env.REDIS_SENTINEL_QUORUM }}
            IS_DEV=${{ env.IS_DEV }}
            CANARY_WEIGHT=${{ env.CANARY_WEIGHT }}
            EOF

            # Secure permissions for .env file
            chmod 600 .env

            # Create or update docker-compose.override.yml for staging
            cat > docker-compose.override.yml <<EOF
            version: '3.8'
            services:
              app:
                image: ghcr.io/${{ steps.repo.outputs.repo }}:staging-latest
                ports:
                  - "80:${{ env.APP_PORT }}"
                environment:
                  - NODE_ENV=development
                  - PORT=${{ env.APP_PORT }}
                  - REDIS_SENTINELS_DEV=${{ env.REDIS_SENTINELS_DEV }}
                  - REDIS_HOST_DEV=${{ env.REDIS_HOST_DEV }}
                  - REDIS_PORT=${{ env.REDIS_PORT }}
                  - REDIS_MASTER_NAME=${{ env.REDIS_MASTER_NAME }}
                  - REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
                  - REDIS_SENTINEL_PASSWORD=${{ secrets.REDIS_SENTINEL_PASSWORD }}
                  - REDIS_SENTINEL_QUORUM=${{ env.REDIS_SENTINEL_QUORUM }}
                  - IS_DEV=${{ env.IS_DEV }}
                  - CANARY_WEIGHT=${{ env.CANARY_WEIGHT }}
                restart: unless-stopped
                healthcheck:
                  test: ["CMD", "wget", "-qO-", "http://localhost:${{ env.APP_PORT }}/health"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 40s
                deploy:
                  resources:
                    limits:
                      cpus: '2'
                      memory: 2G
            EOF

            # Pull the latest image
            echo "Pulling latest image..."
            docker pull ghcr.io/${{ steps.repo.outputs.repo }}:staging-latest || {
              echo "Failed to pull latest image. Using local image if available."
            }

            # Tag the current 'staging-latest' image as 'previous' for rollback capability
            CURRENT_IMAGE=$(docker images ghcr.io/${{ steps.repo.outputs.repo }}:staging-latest -q)
            if [ ! -z "$CURRENT_IMAGE" ]; then
              echo "Tagging current image as previous for rollback capability..."
              docker tag "$CURRENT_IMAGE" ghcr.io/${{ steps.repo.outputs.repo }}:previous
            fi

            # Stop and remove any existing containers gracefully
            echo "Stopping existing containers..."
            docker-compose down --timeout 60 || true

            # Start new containers
            echo "Starting new containers..."
            docker-compose up -d

            # Verify deployment
            echo "Verifying deployment..."
            RETRY_COUNT=0
            MAX_RETRIES=5
            until $(curl --output /dev/null --silent --head --fail http://localhost:80); do
              if [ ${RETRY_COUNT} -eq ${MAX_RETRIES} ]; then
                echo "Deployment verification failed after ${MAX_RETRIES} attempts."
                echo "Rolling back to previous version..."
                docker-compose down
                docker tag ghcr.io/${{ steps.repo.outputs.repo }}:previous ghcr.io/${{ steps.repo.outputs.repo }}:staging-latest
                docker-compose up -d
                exit 1
              fi
              
              echo "Waiting for application to become available... (Attempt $((RETRY_COUNT+1))/${MAX_RETRIES})"
              sleep 10
              RETRY_COUNT=$((RETRY_COUNT+1))
            done

            # Cleanup: prune images to free up space but keep recent ones
            echo "Pruning dangling images..."
            docker image prune -f --filter "until=24h"

            # Keep only the last 3 versions of the images
            echo "Removing old images except the most recent ones..."
            docker images ghcr.io/${{ steps.repo.outputs.repo }} --format "{{.Repository}}:{{.Tag}}:{{.CreatedAt}}" | 
            grep -v ":staging-latest:" | 
            grep -v ":previous:" | 
            sort -r | 
            awk 'NR>3 {print $0}' | 
            cut -d: -f1-2 | 
            xargs -r docker rmi -f || true

            echo "Deployment to staging completed successfully."

      # - name: Notify on Successful Deployment
      #   if: success()
      #   uses: rtCamp/action-slack-notify@v2
      #   env:
      #     SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
      #     SLACK_CHANNEL: deployments
      #     SLACK_COLOR: good
      #     SLACK_TITLE: "Staging Deployment Successful"
      #     SLACK_MESSAGE: "Application deployed successfully to staging environment."
      #     SLACK_ICON: https://github.com/github.png
      #     SLACK_USERNAME: GitHub Actions

      # - name: Notify on Failed Deployment
      #   if: failure()
      #   uses: rtCamp/action-slack-notify@v2
      #   env:
      #     SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
      #     SLACK_CHANNEL: deployments
      #     SLACK_COLOR: danger
      #     SLACK_TITLE: "Staging Deployment Failed"
      #     SLACK_MESSAGE: "Deployment to staging environment failed. Check GitHub Actions logs."
      #     SLACK_ICON: https://github.com/github.png
      #     SLACK_USERNAME: GitHub Actions