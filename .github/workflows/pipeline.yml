name: CI/CD Pipeline
on:
  push:
    branches:
      - main
      - dev
  workflow_dispatch: {}

permissions:
  contents: read
  packages: write

jobs:
  build:
    runs-on: ubuntu-latest
    name: Build Docker Image
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set repository name lower-case
        id: repo
        run: |
          repo=$(echo "${GITHUB_REPOSITORY}" | tr '[:upper:]' '[:lower:]')
          echo "repo=${repo}" >> $GITHUB_OUTPUT

      - name: Log in to GHCR
        uses: docker/login-action@v3.3.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          buildkitd-flags: --debug

      - name: Build and Push Docker Image (Staging)
        if: github.ref == 'refs/heads/dev'
        id: build-staging
        uses: docker/build-push-action@v6.5.0
        with:
          context: .
          push: true
          tags: 'ghcr.io/${{ steps.repo.outputs.repo }}:staging-latest'
          cache-from: type=gha
          cache-to: 'type=gha,mode=max'

      - name: Build and Push Docker Image (Live)
        if: github.ref == 'refs/heads/main'
        id: build-live
        uses: docker/build-push-action@v6.5.0
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ steps.repo.outputs.repo }}:live-latest
            ghcr.io/${{ steps.repo.outputs.repo }}:live-${{ github.sha }}
          cache-from: type=gha
          cache-to: 'type=gha,mode=max'

  deploy-staging:
    needs: build
    if: github.ref == 'refs/heads/dev'
    runs-on: ubuntu-latest
    name: Deploy to Staging Environment
    env:
      PORT: 3000
      NODE_ENV: development
    steps:
      - name: Verify Staging Secrets
        run: |
          for secret in STAGING_HOST STAGING_USER STAGING_SSH_KEY; do
            if [ -z "${!secret}" ]; then
              echo "::error::Secret $secret is not set"
              exit 1
            fi
          done
        env:
          STAGING_HOST: ${{ secrets.STAGING_HOST }}
          STAGING_USER: ${{ secrets.STAGING_USER }}
          STAGING_SSH_KEY: ${{ secrets.STAGING_SSH_KEY }}

      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set repository name lower-case
        id: repo
        run: |
          repo=$(echo "${GITHUB_REPOSITORY}" | tr '[:upper:]' '[:lower:]')
          echo "repo=${repo}" >> $GITHUB_OUTPUT

      - name: Copy docker-compose.yml to remote server
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          source: 'docker-compose.yml,.env.example'
          target: '/home/${{ secrets.STAGING_USER }}/app'

      - name: Deploy to Staging Environment
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            set -euo pipefail
            mkdir -p /home/${{ secrets.STAGING_USER }}/app
            cd /home/${{ secrets.STAGING_USER }}/app

            # Check if Docker is installed, and install it if not
            if ! command -v docker &> /dev/null; then
              echo "Docker not found, installing..."
              sudo apt-get update
              sudo apt-get install -y docker.io
              sudo systemctl start docker
              sudo systemctl enable docker
              sudo usermod -aG docker $USER
            else
              echo "Docker is already installed"
            fi

            # Check if docker-compose is installed, and install it if not
            if ! command -v docker-compose &> /dev/null; then
              echo "docker-compose not found, installing..."
              sudo apt-get update
              sudo apt-get install -y docker-compose
            else
              echo "docker-compose is already installed"
            fi

            echo "Logging into GitHub Container Registry..."
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Create .env file from example or update if exists
            if [ ! -f .env ]; then
              cp .env.example .env
            fi

            # Update environment variables
            cat <<EOF >> .env
            NODE_ENV=development
            PORT=${{ env.PORT }}
            EOF

            # Create or update docker-compose.override.yml for staging
            cat <<EOF > docker-compose.override.yml
            version: '3.8'
            services:
              app:
                image: ghcr.io/${{ steps.repo.outputs.repo }}:staging-latest
                ports:
                  - "80:${{ env.PORT }}"
                environment:
                  - NODE_ENV=development
                  - PORT=${{ env.PORT }}
                restart: always
            EOF

            # Pull the latest image and tag as staging-latest
            docker pull ghcr.io/${{ steps.repo.outputs.repo }}:staging-latest

            # Tag the current 'staging-latest' image as 'previous' if it exists
            CURRENT_IMAGE=$(docker images ghcr.io/${{ steps.repo.outputs.repo }}:staging-latest -q)
            if [ ! -z "$CURRENT_IMAGE" ]; then
              echo "Tagging current latest image as previous..."
              docker tag "$CURRENT_IMAGE" ghcr.io/${{ steps.repo.outputs.repo }}:previous
            fi

            # Stop and remove any existing containers from previous deployments
            echo "Stopping any existing containers..."
            docker-compose down || true

            # Start new containers
            echo "Starting new containers..."
            docker-compose up -d

            # Prune unused images to free up space
            echo "Pruning dangling images..."
            docker image prune -f

            # Remove old images except 'staging-latest' and 'previous'
            echo "Removing old images except 'staging-latest' and 'previous'..."
            docker images ghcr.io/${{ steps.repo.outputs.repo }} --format "{{.Repository}}:{{.Tag}}" | grep -v ":staging-latest$" | grep -v ":previous$" | xargs -r docker rmi -f || true

            echo "Deployment to staging completed successfully."

  deploy-live-canary:
    needs: build
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    name: Deploy to Live Environment (Canary)
    env:
      NODE_ENV: production
      CANARY_WEIGHT: 20
    steps:
      - name: Verify Live Secrets
        run: |
          for secret in LIVE_HOST LIVE_USER LIVE_SSH_KEY APP_PORT REDIS_MASTER_PORT REDIS_SLAVE_1_PORT REDIS_SLAVE_2_PORT SENTINEL_1_PORT SENTINEL_2_PORT SENTINEL_3_PORT REDIS_PASSWORD REDIS_MASTER_NAME REDIS_SENTINEL_QUORUM; do
            if [ -z "${!secret}" ]; then
              echo "::error::Secret $secret is not set"
              exit 1
            fi
          done
        env:
          LIVE_HOST: ${{ secrets.LIVE_HOST }}
          LIVE_USER: ${{ secrets.LIVE_USER }}
          LIVE_SSH_KEY: ${{ secrets.LIVE_SSH_KEY }}
          APP_PORT: ${{ secrets.APP_PORT }}
          REDIS_MASTER_PORT: ${{ secrets.REDIS_MASTER_PORT }}
          REDIS_SLAVE_1_PORT: ${{ secrets.REDIS_SLAVE_1_PORT }}
          REDIS_SLAVE_2_PORT: ${{ secrets.REDIS_SLAVE_2_PORT }}
          SENTINEL_1_PORT: ${{ secrets.SENTINEL_1_PORT }}
          SENTINEL_2_PORT: ${{ secrets.SENTINEL_2_PORT }}
          SENTINEL_3_PORT: ${{ secrets.SENTINEL_3_PORT }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          REDIS_MASTER_NAME: ${{ secrets.REDIS_MASTER_NAME }}
          REDIS_SENTINEL_QUORUM: ${{ secrets.REDIS_SENTINEL_QUORUM }}

      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set repository name lower-case
        id: repo
        run: |
          repo=$(echo "${GITHUB_REPOSITORY}" | tr '[:upper:]' '[:lower:]')
          echo "repo=${repo}" >> $GITHUB_OUTPUT

      - name: Copy docker-compose files to remote server
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.LIVE_HOST }}
          username: ${{ secrets.LIVE_USER }}
          key: ${{ secrets.LIVE_SSH_KEY }}
          source: 'docker-compose.yml,.env.example'
          target: '/home/${{ secrets.LIVE_USER }}/app'

      - name: Deploy Canary Release
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.LIVE_HOST }}
          username: ${{ secrets.LIVE_USER }}
          key: ${{ secrets.LIVE_SSH_KEY }}
          script: |
            set -euo pipefail
            mkdir -p /home/${{ secrets.LIVE_USER }}/app
            cd /home/${{ secrets.LIVE_USER }}/app

            # Check if Docker is installed, and install it if not
            if ! command -v docker &> /dev/null; then
              echo "Docker not found, installing..."
              sudo apt-get update
              sudo apt-get install -y docker.io
              sudo systemctl start docker
              sudo systemctl enable docker
              sudo usermod -aG docker $USER
            else
              echo "Docker is already installed"
            fi

            # Check if docker-compose is installed, and install it if not
            if ! command -v docker-compose &> /dev/null; then
              echo "docker-compose not found, installing..."
              sudo apt-get update
              sudo apt-get install -y docker-compose
            else
              echo "docker-compose is already installed"
            fi

            echo "Logging into GHCR..."
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin

            # Create .env file from example or update if exists
            if [ ! -f .env ]; then
              cp .env.example .env
            fi

            # Update environment variables for production
            cat <<EOF >> .env
            NODE_ENV=production
            APP_PORT=${{ secrets.APP_PORT }}
            REDIS_MASTER_PORT=${{ secrets.REDIS_MASTER_PORT }}
            REDIS_SLAVE_1_PORT=${{ secrets.REDIS_SLAVE_1_PORT }}
            REDIS_SLAVE_2_PORT=${{ secrets.REDIS_SLAVE_2_PORT }}
            SENTINEL_1_PORT=${{ secrets.SENTINEL_1_PORT }}
            SENTINEL_2_PORT=${{ secrets.SENTINEL_2_PORT }}
            SENTINEL_3_PORT=${{ secrets.SENTINEL_3_PORT }}
            REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
            REDIS_MASTER_NAME=${{ secrets.REDIS_MASTER_NAME }}
            REDIS_SENTINEL_QUORUM=${{ secrets.REDIS_SENTINEL_QUORUM }}
            REDIS_SENTINELS=sentinel-1:${{ secrets.SENTINEL_1_PORT }},sentinel-2:${{ secrets.SENTINEL_2_PORT }},sentinel-3:${{ secrets.SENTINEL_3_PORT }}
            EOF

            # Pull the latest image and the specific commit hash image
            echo "Pulling latest live image..."
            docker pull ghcr.io/${{ steps.repo.outputs.repo }}:live-latest
            docker pull ghcr.io/${{ steps.repo.outputs.repo }}:live-${{ github.sha }}

            # Check if we have stable and canary containers running
            STABLE_RUNNING=$(docker ps -q -f name=nextjs-app-stable || true)
            CANARY_RUNNING=$(docker ps -q -f name=nextjs-app-canary || true)

            # Create or update docker-compose.override.yml for canary deployment
            cat <<EOF > docker-compose.override.yml
            version: '3.8'

            services:
              redis-master:
                image: redis:7.0
                command: redis-server --requirepass ${{ secrets.REDIS_PASSWORD }}
                ports:
                  - "${{ secrets.REDIS_MASTER_PORT }}:6379"

              redis-slave-1:
                image: redis:7.0
                command: redis-server --slaveof redis-master 6379 --requirepass ${{ secrets.REDIS_PASSWORD }} --masterauth ${{ secrets.REDIS_PASSWORD }}
                ports:
                  - "${{ secrets.REDIS_SLAVE_1_PORT }}:6379"
                depends_on:
                  - redis-master

              redis-slave-2:
                image: redis:7.0
                command: redis-server --slaveof redis-master 6379 --requirepass ${{ secrets.REDIS_PASSWORD }} --masterauth ${{ secrets.REDIS_PASSWORD }}
                ports:
                  - "${{ secrets.REDIS_SLAVE_2_PORT }}:6379"
                depends_on:
                  - redis-master

              sentinel-1:
                image: redis:7.0
                command: redis-sentinel /etc/redis/sentinel.conf
                ports:
                  - "${{ secrets.SENTINEL_1_PORT }}:26379"
                depends_on:
                  - redis-master
                  - redis-slave-1
                  - redis-slave-2
                volumes:
                  - ./sentinel-1.conf:/etc/redis/sentinel.conf

              sentinel-2:
                image: redis:7.0
                command: redis-sentinel /etc/redis/sentinel.conf
                ports:
                  - "${{ secrets.SENTINEL_2_PORT }}:26379"
                depends_on:
                  - redis-master
                  - redis-slave-1
                  - redis-slave-2
                volumes:
                  - ./sentinel-2.conf:/etc/redis/sentinel.conf

              sentinel-3:
                image: redis:7.0
                command: redis-sentinel /etc/redis/sentinel.conf
                ports:
                  - "${{ secrets.SENTINEL_3_PORT }}:26379"
                depends_on:
                  - redis-master
                  - redis-slave-1
                  - redis-slave-2
                volumes:
                  - ./sentinel-3.conf:/etc/redis/sentinel.conf

              app-stable:
                image: ghcr.io/${{ steps.repo.outputs.repo }}:live-latest
                container_name: nextjs-app-stable
                environment:
                  - NODE_ENV=production
                  - APP_PORT=${{ secrets.APP_PORT }}
                  - REDIS_SENTINELS=sentinel-1:${{ secrets.SENTINEL_1_PORT }},sentinel-2:${{ secrets.SENTINEL_2_PORT }},sentinel-3:${{ secrets.SENTINEL_3_PORT }}
                  - REDIS_MASTER_NAME=${{ secrets.REDIS_MASTER_NAME }}
                  - REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
                  - REDIS_SENTINEL_QUORUM=${{ secrets.REDIS_SENTINEL_QUORUM }}
                ports:
                  - "3001:${{ secrets.APP_PORT }}"
                restart: always
                depends_on:
                  - redis-master
                  - sentinel-1
                  - sentinel-2
                  - sentinel-3

              app-canary:
                image: ghcr.io/${{ steps.repo.outputs.repo }}:live-${{ github.sha }}
                container_name: nextjs-app-canary
                environment:
                  - NODE_ENV=production
                  - APP_PORT=${{ secrets.APP_PORT }}
                  - REDIS_SENTINELS=sentinel-1:${{ secrets.SENTINEL_1_PORT }},sentinel-2:${{ secrets.SENTINEL_2_PORT }},sentinel-3:${{ secrets.SENTINEL_3_PORT }}
                  - REDIS_MASTER_NAME=${{ secrets.REDIS_MASTER_NAME }}
                  - REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
                  - REDIS_SENTINEL_QUORUM=${{ secrets.REDIS_SENTINEL_QUORUM }}
                ports:
                  - "3002:${{ secrets.APP_PORT }}"
                restart: always
                depends_on:
                  - redis-master
                  - sentinel-1
                  - sentinel-2
                  - sentinel-3
            EOF

            # Create sentinel configuration files
            for i in {1..3}; do
              cat <<EOF > sentinel-$i.conf
            port 26379
            sentinel monitor ${{ secrets.REDIS_MASTER_NAME }} redis-master 6379 ${{ secrets.REDIS_SENTINEL_QUORUM }}
            sentinel auth-pass ${{ secrets.REDIS_MASTER_NAME }} ${{ secrets.REDIS_PASSWORD }}
            sentinel down-after-milliseconds ${{ secrets.REDIS_MASTER_NAME }} 5000
            sentinel failover-timeout ${{ secrets.REDIS_MASTER_NAME }} 60000
            sentinel parallel-syncs ${{ secrets.REDIS_MASTER_NAME }} 1
            EOF
            done

            # Bring up Redis services and application containers
            echo "Starting Redis services and application containers..."
            docker-compose up -d

            # Wait for services to be ready
            echo "Waiting for services to be ready..."
            sleep 10

            # Configure Nginx for canary deployment
            echo "Updating Nginx configuration for canary deployment..."

            # Create nginx configuration for canary routing
            sudo mkdir -p /etc/nginx/conf.d

            cat <<EOF | sudo tee /etc/nginx/conf.d/nextjs-app.conf
            upstream nextjs_stable {
                server 127.0.0.1:3001;
            }

            upstream nextjs_canary {
                server 127.0.0.1:3002;
            }

            # Map to determine which upstream to use based on probability
            map \$request_id \$upstream {
                # Send ~${{ env.CANARY_WEIGHT }}% of traffic to canary
                ~^.{0,2}[0-${{ env.CANARY_WEIGHT }}].*$    nextjs_canary;
                default                         nextjs_stable;
            }

            server {
                listen 80;
                
                # Add header to identify which version is serving the request
                add_header X-Version \$upstream;
                
                location / {
                    proxy_pass http://\$upstream;
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Request-ID \$request_id;
                }
            }
            EOF

            # Check if nginx is installed
            if ! command -v nginx &> /dev/null; then
                echo "Nginx not found, installing..."
                sudo apt-get update
                sudo apt-get install -y nginx
            fi

            # Test nginx configuration
            sudo nginx -t

            # Reload nginx if configuration is valid
            if [ $? -eq 0 ]; then
                echo "Reloading Nginx..."
                sudo systemctl reload nginx
            else
                echo "Nginx configuration error detected. Please check configuration."
                exit 1
            fi

            echo "Canary deployment completed successfully. Routing ${{ env.CANARY_WEIGHT }}% of traffic to the new version."
            echo "Monitor the canary deployment before promoting it to stable."

  promote-canary:
    needs: deploy-live-canary
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    name: Promote Canary to Stable (Manual Approval)
    # environment: 
    #   name: Production
    #   url: ${{ secrets.LIVE_HOST }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set repository name lower-case
        id: repo
        run: |
          repo=$(echo "${GITHUB_REPOSITORY}" | tr '[:upper:]' '[:lower:]')
          echo "repo=${repo}" >> $GITHUB_OUTPUT

      - name: Promote Canary to Stable
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.LIVE_HOST }}
          username: ${{ secrets.LIVE_USER }}
          key: ${{ secrets.LIVE_SSH_KEY }}
          script: |
            set -euo pipefail
            cd /home/${{ secrets.LIVE_USER }}/app

            echo "Promoting canary deployment to stable..."

            # Tag the canary image as the new stable
            docker tag ghcr.io/${{ steps.repo.outputs.repo }}:live-${{ github.sha }} ghcr.io/${{ steps.repo.outputs.repo }}:live-latest

            # Update nginx configuration to direct all traffic to the promoted canary
            cat <<EOF | sudo tee /etc/nginx/conf.d/nextjs-app.conf
            upstream nextjs_app {
                server 127.0.0.1:3001;
            }

            server {
                listen 80;
                
                # Add header to identify which version is serving the request
                add_header X-Version stable;
                
                location / {
                    proxy_pass http://nextjs_app;
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                }
            }
            EOF

            # Reload nginx
            sudo nginx -t && sudo systemctl reload nginx

            # Update stable container with the promoted image
            docker-compose stop app-stable
            docker-compose rm -f app-stable
            docker-compose up -d app-stable

            # Clean up the canary container
            docker-compose stop app-canary
            docker-compose rm -f app-canary

            # Prune unused images
            docker image prune -f

            echo "Canary deployment successfully promoted to stable."

  rollback:
    if: failure() && github.ref == 'refs/heads/main'
    needs: [deploy-live-canary]
    runs-on: ubuntu-latest
    name: Rollback Canary Deployment
    steps:
      - name: Rollback to Stable Version
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.LIVE_HOST }}
          username: ${{ secrets.LIVE_USER }}
          key: ${{ secrets.LIVE_SSH_KEY }}
          script: |
            set -euo pipefail
            cd /home/${{ secrets.LIVE_USER }}/app

            echo "Deployment failed! Rolling back to stable version..."

            # Update nginx configuration to direct all traffic to stable
            cat <<EOF | sudo tee /etc/nginx/conf.d/nextjs-app.conf
            upstream nextjs_app {
                server 127.0.0.1:3001;
            }

            server {
                listen 80;
                
                location / {
                    proxy_pass http://nextjs_app;
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                }
            }
            EOF

            # Reload nginx
            sudo nginx -t && sudo systemctl reload nginx

            # Clean up the canary container
            docker-compose stop app-canary || true
            docker-compose rm -f app-canary || true

            echo "Rollback completed successfully."